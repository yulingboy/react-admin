# 2025-04-22-微服务网关设计与实现

## 时间：2025-04-22 18:30

## 完成内容

在微服务架构改造过程中，完成了API网关的详细设计文档。本文档阐述了在单仓微服务架构中，API网关的职责、功能设计以及具体实现方案。

## 一、API网关概述

### 1.1 网关定位与职责

API网关在微服务架构中处于核心位置，作为所有客户端请求的统一入口，承担以下核心职责：

- **请求路由**：将请求路由到正确的微服务
- **认证鉴权**：集中处理用户认证和权限控制
- **负载均衡**：在多个服务实例间分发请求
- **请求转换**：对请求和响应格式进行统一处理
- **限流熔断**：保护后端服务免受过载和异常影响
- **监控日志**：收集请求数据用于监控和分析
- **协议转换**：对外统一提供RESTful API，内部可使用不同协议通信

### 1.2 网关选型

针对我们的单仓微服务架构，API网关的选型有以下几种方案：

| 方案 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| 自研NestJS网关 | 与现有技术栈一致，定制性强 | 需要自行实现各种功能 | 功能需求特殊，需深度定制 |
| Spring Cloud Gateway | 功能丰富，生态完善 | 引入Java技术栈 | 大型企业级应用 |
| Kong | 高性能，插件丰富 | 配置复杂，学习曲线陡峭 | 高并发、多租户场景 |
| NGINX/NGINX+ | 轻量高效，功能强大 | 动态配置能力有限 | 性能要求高的场景 |
| Traefik | 自动服务发现，配置简单 | 企业级功能较少 | 容器化部署环境 |

基于我们现有的技术栈和项目需求，推荐采用**自研NestJS网关 + NGINX**的组合方案：
- NGINX作为前置代理，处理SSL终结、静态资源和基础负载均衡
- NestJS网关负责业务路由、认证鉴权和服务间协议转换

## 二、网关功能设计

### 2.1 核心功能模块

#### 2.1.1 路由模块

**功能描述**：
- 维护服务路由映射表
- 支持动态路由配置
- 实现请求转发和负载均衡

**实现方案**：
```typescript
// 路由配置接口
interface ServiceRoute {
  path: string;          // 路由路径
  serviceId: string;     // 目标服务ID
  stripPrefix: boolean;  // 是否去除前缀
  methods?: string[];    // 支持的HTTP方法
  timeout?: number;      // 超时时间(毫秒)
}

// 示例配置
const routes: ServiceRoute[] = [
  {
    path: '/api/auth',
    serviceId: 'auth-service',
    stripPrefix: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    timeout: 5000
  },
  {
    path: '/api/system',
    serviceId: 'system-service',
    stripPrefix: true
  }
];
```

#### 2.1.2 认证鉴权模块

**功能描述**：
- 集中处理JWT令牌验证
- 实现基于角色的访问控制(RBAC)
- 支持API级别的权限控制
- 提供统一的认证错误处理

**实现方案**：
```typescript
// 权限配置接口
interface PermissionConfig {
  path: string;          // API路径正则
  method: string;        // HTTP方法
  roles: string[];       // 允许访问的角色
  isPublic?: boolean;    // 是否为公开接口
}

// 示例配置
const permissions: PermissionConfig[] = [
  {
    path: '^/api/auth/login',
    method: 'POST',
    roles: [],
    isPublic: true
  },
  {
    path: '^/api/system/configs',
    method: 'GET',
    roles: ['admin', 'user']
  },
  {
    path: '^/api/system/configs',
    method: 'POST',
    roles: ['admin']
  }
];
```

#### 2.1.3 限流熔断模块

**功能描述**：
- 实现基于IP的限流
- 实现基于用户的限流
- 实现基于服务的限流
- 支持熔断器模式

**实现方案**：
```typescript
// 限流配置接口
interface RateLimitConfig {
  type: 'ip' | 'user' | 'service';  // 限流类型
  limit: number;                    // 限制次数
  duration: number;                 // 时间窗口(秒)
  path?: string;                    // 适用路径(可选)
}

// 示例配置
const rateLimits: RateLimitConfig[] = [
  {
    type: 'ip',
    limit: 100,
    duration: 60
  },
  {
    type: 'user',
    limit: 30,
    duration: 60,
    path: '/api/finance'
  },
  {
    type: 'service',
    limit: 500,
    duration: 60,
    path: '/api/auth'
  }
];
```

#### 2.1.4 监控日志模块

**功能描述**：
- 统一记录请求日志
- 收集性能指标
- 监控服务健康状态
- 支持请求追踪

**实现方案**：
```typescript
// 日志格式定义
interface ApiLog {
  timestamp: string;        // 时间戳
  requestId: string;        // 请求ID
  path: string;             // 请求路径
  method: string;           // HTTP方法
  userId?: number;          // 用户ID(可选)
  ip: string;               // 客户端IP
  status: number;           // 响应状态码
  duration: number;         // 处理时间(毫秒)
  serviceId: string;        // 目标服务ID
  userAgent: string;        // 用户代理
  requestBody?: any;        // 请求体(可选)
  responseBody?: any;       // 响应体(可选)
  error?: string;           // 错误信息(可选)
}
```

#### 2.1.5 响应缓存模块

**功能描述**：
- 针对只读请求实现响应缓存
- 支持按路径配置缓存策略
- 支持缓存手动和自动失效

**实现方案**：
```typescript
// 缓存配置接口
interface CacheConfig {
  path: string;           // 路径模式
  method: string;         // HTTP方法
  ttl: number;            // 缓存有效期(秒)
  varyByUser: boolean;    // 是否按用户缓存
  varyByParams: string[]; // 影响缓存的查询参数
}

// 示例配置
const cacheConfigs: CacheConfig[] = [
  {
    path: '^/api/system/dictionaries',
    method: 'GET',
    ttl: 3600,
    varyByUser: false,
    varyByParams: ['code']
  },
  {
    path: '^/api/auth/user/info',
    method: 'GET',
    ttl: 300,
    varyByUser: true,
    varyByParams: []
  }
];
```

### 2.2 高级功能设计

#### 2.2.1 服务发现与注册

**功能描述**：
- 服务实例自动注册
- 健康检查和故障检测
- 支持服务实例扩缩容

**实现方案**：
- 使用Redis作为服务注册中心
- 基于心跳机制实现健康检查
- 支持权重配置和服务分组

#### 2.2.2 灰度发布支持

**功能描述**：
- 支持按用户类型路由到不同版本服务
- 支持按比例分配流量
- 支持A/B测试场景

**实现方案**：
```typescript
// 灰度发布配置
interface GrayReleaseConfig {
  serviceId: string;              // 服务ID
  rules: Array<{
    weight: number;               // 权重(百分比)
    version: string;              // 服务版本
    condition?: {                 // 条件(可选)
      header?: Record<string, string>;  // 匹配请求头
      param?: Record<string, string>;   // 匹配查询参数
      userId?: number[];                // 用户ID列表
      userRole?: string[];              // 用户角色列表
    }
  }>;
}
```

#### 2.2.3 统一错误处理

**功能描述**：
- 统一处理微服务错误响应
- 提供友好的错误信息
- 隐藏敏感的异常细节
- 支持错误代码映射

**实现方案**：
```typescript
// 错误响应格式
interface ErrorResponse {
  status: number;       // HTTP状态码
  code: string;         // 业务错误代码
  message: string;      // 友好错误消息
  details?: any;        // 错误详情(可选)
  timestamp: string;    // 时间戳
  path: string;         // 请求路径
  traceId: string;      // 追踪ID
}
```

#### 2.2.4 API文档聚合

**功能描述**：
- 聚合所有微服务的API文档
- 提供统一的API文档入口
- 支持API测试功能

**实现方案**：
- 使用Swagger聚合各服务API文档
- 配置API文档访问权限
- 集成API测试工具

## 三、技术实现

### 3.1 网关服务基础结构

```typescript
// 网关服务主模块
// apps/gateway/src/gateway.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { APP_FILTER, APP_GUARD, APP_INTERCEPTOR } from '@nestjs/core';
import { RedisModule } from '@app/cache';
import { JwtModule } from '@nestjs/jwt';

import { GatewayController } from './gateway.controller';
import { RouterModule } from './router/router.module';
import { AuthModule } from './auth/auth.module';
import { RateLimiterModule } from './rate-limiter/rate-limiter.module';
import { LoggerModule } from './logger/logger.module';
import { CacheModule } from './cache/cache.module';

import { AuthGuard } from './auth/guards/auth.guard';
import { RoleGuard } from './auth/guards/role.guard';
import { RateLimiterInterceptor } from './rate-limiter/interceptors/rate-limiter.interceptor';
import { LoggingInterceptor } from './logger/interceptors/logging.interceptor';
import { HttpExceptionFilter } from './filters/http-exception.filter';
import { AllExceptionsFilter } from './filters/all-exceptions.filter';

@Module({
  imports: [
    // 配置模块
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: ['.env.gateway', '.env'],
    }),
    
    // JWT模块
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN', '1h'),
        },
      }),
    }),
    
    // Redis缓存模块
    RedisModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        host: configService.get<string>('REDIS_HOST', 'localhost'),
        port: configService.get<number>('REDIS_PORT', 6379),
        password: configService.get<string>('REDIS_PASSWORD', ''),
        db: configService.get<number>('REDIS_DB', 0),
      }),
    }),
    
    // 网关功能模块
    RouterModule,      // 路由模块
    AuthModule,        // 认证模块
    RateLimiterModule, // 限流模块
    LoggerModule,      // 日志模块
    CacheModule,       // 缓存模块
  ],
  controllers: [GatewayController],
  providers: [
    // 全局异常过滤器
    {
      provide: APP_FILTER,
      useClass: AllExceptionsFilter,
    },
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
    
    // 全局认证守卫
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
    
    // 全局角色守卫
    {
      provide: APP_GUARD,
      useClass: RoleGuard,
    },
    
    // 全局拦截器
    {
      provide: APP_INTERCEPTOR,
      useClass: RateLimiterInterceptor,
    },
    {
      provide: APP_INTERCEPTOR,
      useClass: LoggingInterceptor,
    },
  ],
})
export class GatewayModule {}
```

### 3.2 路由模块实现

```typescript
// 路由模块
// apps/gateway/src/router/router.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { RouterService } from './router.service';
import { ServiceRegistryService } from './service-registry.service';
import { RouteConfigService } from './route-config.service';
import { ProxyController } from './proxy.controller';

@Module({
  imports: [ConfigModule],
  controllers: [ProxyController],
  providers: [
    RouterService,
    ServiceRegistryService,
    RouteConfigService,
  ],
  exports: [RouterService, ServiceRegistryService],
})
export class RouterModule {}
```

路由服务实现：

```typescript
// 路由服务
// apps/gateway/src/router/router.service.ts
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '@nestjs/axios';
import { ServiceRegistryService } from './service-registry.service';
import { RouteConfigService } from './route-config.service';
import { ServiceRoute } from './interfaces/service-route.interface';
import { ServiceInstance } from './interfaces/service-instance.interface';
import { lastValueFrom } from 'rxjs';

@Injectable()
export class RouterService implements OnModuleInit {
  private readonly logger = new Logger(RouterService.name);
  
  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
    private readonly serviceRegistry: ServiceRegistryService,
    private readonly routeConfig: RouteConfigService,
  ) {}
  
  /**
   * 模块初始化
   */
  async onModuleInit() {
    // 从配置加载路由规则
    await this.routeConfig.loadRoutes();
    
    // 初始化服务注册表
    await this.serviceRegistry.initialize();
    
    this.logger.log('Router module initialized');
  }
  
  /**
   * 转发请求到目标服务
   * @param route 路由规则
   * @param req 原始请求
   * @param body 请求体
   * @returns 目标服务响应
   */
  async forwardRequest(route: ServiceRoute, req: any, body: any): Promise<any> {
    // 获取服务实例
    const serviceInstance = await this.getServiceInstance(route.serviceId);
    if (!serviceInstance) {
      throw new Error(`Service ${route.serviceId} is not available`);
    }
    
    // 构建目标URL
    const targetPath = this.buildTargetPath(route, req.url);
    const targetUrl = `${serviceInstance.protocol}://${serviceInstance.host}:${serviceInstance.port}${targetPath}`;
    
    // 转发请求
    try {
      const startTime = Date.now();
      
      // 构建请求配置
      const requestConfig = {
        method: req.method,
        url: targetUrl,
        headers: this.filterHeaders(req.headers),
        data: body,
        timeout: route.timeout || this.configService.get('DEFAULT_TIMEOUT', 10000),
        maxRedirects: 5,
      };
      
      // 发送请求
      const response = await lastValueFrom(
        this.httpService.request(requestConfig)
      );
      
      const duration = Date.now() - startTime;
      this.logger.debug(`Request to ${targetUrl} completed in ${duration}ms`);
      
      return {
        status: response.status,
        headers: response.headers,
        data: response.data,
      };
    } catch (error) {
      this.logger.error(`Error forwarding request to ${targetUrl}: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * 获取服务实例（包含负载均衡）
   * @param serviceId 服务ID
   * @returns 服务实例
   */
  private async getServiceInstance(serviceId: string): Promise<ServiceInstance | null> {
    return this.serviceRegistry.getServiceInstance(serviceId);
  }
  
  /**
   * 构建目标路径
   * @param route 路由规则
   * @param originalUrl 原始URL
   * @returns 目标路径
   */
  private buildTargetPath(route: ServiceRoute, originalUrl: string): string {
    if (route.stripPrefix) {
      return originalUrl.replace(new RegExp(`^${route.path}`), '');
    }
    return originalUrl;
  }
  
  /**
   * 过滤需要转发的请求头
   * @param headers 原始请求头
   * @returns 过滤后的请求头
   */
  private filterHeaders(headers: Record<string, any>): Record<string, any> {
    const result = { ...headers };
    
    // 移除不需要转发的请求头
    const headersToRemove = [
      'host',
      'connection',
      'content-length',
      'sec-fetch-mode',
      'sec-fetch-site',
      'sec-fetch-dest',
    ];
    
    headersToRemove.forEach(header => {
      delete result[header];
    });
    
    return result;
  }
}
```

代理控制器实现：

```typescript
// 代理控制器
// apps/gateway/src/router/proxy.controller.ts
import { All, Controller, Req, Res, Body, Param, Logger } from '@nestjs/common';
import { Request, Response } from 'express';
import { RouterService } from './router.service';
import { RouteConfigService } from './route-config.service';

@Controller('*')
export class ProxyController {
  private readonly logger = new Logger(ProxyController.name);
  
  constructor(
    private readonly routerService: RouterService,
    private readonly routeConfig: RouteConfigService,
  ) {}
  
  /**
   * 处理所有HTTP请求
   * @param req 请求对象
   * @param res 响应对象
   * @param body 请求体
   */
  @All()
  async handleRequest(
    @Req() req: Request,
    @Res() res: Response,
    @Body() body: any,
  ) {
    const path = req.url;
    const method = req.method;
    
    this.logger.debug(`Received ${method} request for ${path}`);
    
    // 查找匹配的路由
    const route = this.routeConfig.findRoute(path, method);
    if (!route) {
      this.logger.warn(`No route found for ${method} ${path}`);
      return res.status(404).json({
        status: 404,
        message: 'Not Found',
        path,
      });
    }
    
    try {
      // 转发请求
      const response = await this.routerService.forwardRequest(route, req, body);
      
      // 设置响应头
      Object.keys(response.headers).forEach(header => {
        res.setHeader(header, response.headers[header]);
      });
      
      // 发送响应
      return res.status(response.status).json(response.data);
    } catch (error) {
      // 错误会由全局异常过滤器处理
      throw error;
    }
  }
}
```

### 3.3 认证模块实现

```typescript
// 认证守卫
// apps/gateway/src/auth/guards/auth.guard.ts
import { Injectable, CanActivate, ExecutionContext, Logger, UnauthorizedException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';
import { AuthService } from '../auth.service';
import { AuthConfigService } from '../auth-config.service';

@Injectable()
export class AuthGuard implements CanActivate {
  private readonly logger = new Logger(AuthGuard.name);
  
  constructor(
    private readonly reflector: Reflector,
    private readonly jwtService: JwtService,
    private readonly authService: AuthService,
    private readonly authConfig: AuthConfigService,
  ) {}
  
  /**
   * 验证请求是否可以通过
   * @param context 执行上下文
   * @returns 是否允许请求通过
   */
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<Request>();
    const path = request.url;
    const method = request.method;
    
    // 检查是否为公开API
    if (this.authConfig.isPublicRoute(path, method)) {
      return true;
    }
    
    // 获取并验证令牌
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException('Missing authentication token');
    }
    
    try {
      // 验证令牌
      const payload = await this.jwtService.verifyAsync(token);
      
      // 添加用户信息到请求对象
      request['user'] = payload;
      
      // 验证令牌是否在Redis有效
      const isValid = await this.authService.validateToken(payload.sub, token);
      if (!isValid) {
        throw new UnauthorizedException('Invalid or expired token');
      }
      
      // 刷新token有效期
      await this.authService.refreshToken(payload.sub);
      
      return true;
    } catch (error) {
      this.logger.error(`Authentication failed: ${error.message}`);
      throw new UnauthorizedException('Invalid token');
    }
  }
  
  /**
   * 从请求头中提取令牌
   * @param request 请求对象
   * @returns 令牌或undefined
   */
  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

权限守卫实现：

```typescript
// 角色守卫
// apps/gateway/src/auth/guards/role.guard.ts
import { Injectable, CanActivate, ExecutionContext, Logger, ForbiddenException } from '@nestjs/common';
import { Request } from 'express';
import { AuthConfigService } from '../auth-config.service';

@Injectable()
export class RoleGuard implements CanActivate {
  private readonly logger = new Logger(RoleGuard.name);
  
  constructor(
    private readonly authConfig: AuthConfigService,
  ) {}
  
  /**
   * 验证用户是否有权限访问
   * @param context 执行上下文
   * @returns 是否允许请求通过
   */
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<Request>();
    const path = request.url;
    const method = request.method;
    
    // 检查是否为公开API
    if (this.authConfig.isPublicRoute(path, method)) {
      return true;
    }
    
    // 获取用户信息
    const user = request['user'];
    if (!user) {
      return false; // 应该由AuthGuard阻止
    }
    
    // 检查用户角色
    const userRoles = user.roles || [];
    const requiredRoles = this.authConfig.getRequiredRoles(path, method);
    
    // 如果没有设置角色要求，允许访问
    if (!requiredRoles || requiredRoles.length === 0) {
      return true;
    }
    
    // 检查用户是否拥有所需角色
    const hasRole = userRoles.some(role => requiredRoles.includes(role));
    if (!hasRole) {
      this.logger.warn(`User ${user.sub} with roles [${userRoles.join(', ')}] attempted to access ${method} ${path} but required roles are [${requiredRoles.join(', ')}]`);
      throw new ForbiddenException('Insufficient permissions');
    }
    
    return true;
  }
}
```

认证服务实现：

```typescript
// 认证服务
// apps/gateway/src/auth/auth.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { AuthCacheService } from '@app/cache';

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);
  
  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly authCache: AuthCacheService,
  ) {}
  
  /**
   * 验证令牌是否有效
   * @param userId 用户ID
   * @param token JWT令牌
   * @returns 是否有效
   */
  async validateToken(userId: number, token: string): Promise<boolean> {
    return this.authCache.validateToken(userId, token);
  }
  
  /**
   * 刷新令牌有效期
   * @param userId 用户ID
   */
  async refreshToken(userId: number): Promise<void> {
    await this.authCache.refreshSession(userId);
  }
  
  /**
   * 获取用户会话数据
   * @param userId 用户ID
   */
  async getUserSession(userId: number): Promise<any> {
    return this.authCache.getUserSession(userId);
  }
}
```

### 3.4 限流模块实现

```typescript
// 限流拦截器
// apps/gateway/src/rate-limiter/interceptors/rate-limiter.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, Logger, HttpException, HttpStatus } from '@nestjs/common';
import { Observable } from 'rxjs';
import { Request } from 'express';
import { RateLimiterService } from '../rate-limiter.service';
import { RateLimiterConfigService } from '../rate-limiter-config.service';

@Injectable()
export class RateLimiterInterceptor implements NestInterceptor {
  private readonly logger = new Logger(RateLimiterInterceptor.name);
  
  constructor(
    private readonly rateLimiterService: RateLimiterService,
    private readonly configService: RateLimiterConfigService,
  ) {}
  
  /**
   * 拦截请求进行限流控制
   * @param context 执行上下文
   * @param next 下一个处理器
   */
  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest<Request>();
    const path = request.url;
    const method = request.method;
    const ip = request.ip;
    const user = request['user'];
    
    // 检查是否需要限流
    const ipLimits = this.configService.getIpLimits(path);
    const userLimits = user && this.configService.getUserLimits(path);
    const serviceLimits = this.configService.getServiceLimits(path);
    
    try {
      // 根据IP限流
      if (ipLimits) {
        const key = `rate:ip:${ip}:${path}`;
        await this.rateLimiterService.checkRateLimit(key, ipLimits.limit, ipLimits.duration);
      }
      
      // 根据用户限流
      if (userLimits && user) {
        const key = `rate:user:${user.sub}:${path}`;
        await this.rateLimiterService.checkRateLimit(key, userLimits.limit, userLimits.duration);
      }
      
      // 根据服务限流
      if (serviceLimits) {
        const key = `rate:service:${path}`;
        await this.rateLimiterService.checkRateLimit(key, serviceLimits.limit, serviceLimits.duration);
      }
      
      // 继续处理请求
      return next.handle();
    } catch (error) {
      this.logger.warn(`Rate limit exceeded for ${path}: ${error.message}`);
      throw new HttpException({
        status: HttpStatus.TOO_MANY_REQUESTS,
        message: 'Rate limit exceeded',
        path,
      }, HttpStatus.TOO_MANY_REQUESTS);
    }
  }
}
```

限流服务实现：

```typescript
// 限流服务
// apps/gateway/src/rate-limiter/rate-limiter.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RedisService } from '@app/cache';

@Injectable()
export class RateLimiterService {
  private readonly logger = new Logger(RateLimiterService.name);
  
  constructor(
    private readonly redisService: RedisService,
  ) {}
  
  /**
   * 检查是否超过限流阈值
   * @param key 限流键
   * @param limit 限制次数
   * @param duration 时间窗口(秒)
   */
  async checkRateLimit(key: string, limit: number, duration: number): Promise<void> {
    // 使用Redis滑动窗口实现限流
    const now = Date.now();
    const windowStart = now - duration * 1000;
    
    // 使用管道批量执行命令
    const pipeline = this.redisService.pipeline();
    
    // 移除窗口外的请求记录
    pipeline.zremrangebyscore(key, 0, windowStart);
    
    // 添加当前请求记录
    pipeline.zadd(key, now, now.toString());
    
    // 获取窗口内的请求数量
    pipeline.zcard(key);
    
    // 设置过期时间
    pipeline.expire(key, duration * 2); // 设置为窗口时间的2倍，确保数据清理
    
    // 执行命令
    const results = await pipeline.exec();
    
    // 检查请求数量
    const requestCount = results[2][1] as number;
    
    if (requestCount > limit) {
      this.logger.warn(`Rate limit exceeded for ${key}: ${requestCount}/${limit}`);
      throw new Error(`Rate limit exceeded: ${requestCount}/${limit}`);
    }
  }
}
```

### 3.5 监控日志模块实现

```typescript
// 日志拦截器
// apps/gateway/src/logger/interceptors/logging.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, Logger } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { LoggerService } from '../logger.service';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggingInterceptor.name);
  
  constructor(
    private readonly loggerService: LoggerService,
  ) {}
  
  /**
   * 拦截请求进行日志记录
   * @param context 执行上下文
   * @param next 下一个处理器
   */
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();
    
    // 生成请求ID
    const requestId = uuidv4();
    request['requestId'] = requestId;
    
    // 设置请求ID响应头
    response.setHeader('X-Request-ID', requestId);
    
    // 记录请求开始时间
    const startTime = Date.now();
    
    // 获取请求信息
    const { method, url, ip, headers } = request;
    const userAgent = headers['user-agent'] || 'unknown';
    const user = request['user'];
    
    this.logger.debug(`[${requestId}] ${method} ${url} started`);
    
    // 继续处理请求，并在完成后记录响应信息
    return next.handle().pipe(
      tap({
        next: (data) => {
          // 请求成功
          const duration = Date.now() - startTime;
          const status = response.statusCode;
          
          // 记录请求日志
          this.loggerService.logRequest({
            timestamp: new Date().toISOString(),
            requestId,
            path: url,
            method,
            userId: user?.sub,
            ip,
            status,
            duration,
            serviceId: 'gateway', // 网关处理的请求
            userAgent,
            requestBody: request.body, // 根据需要可以记录请求体
            responseBody: data, // 根据需要可以记录响应体
          });
          
          this.logger.debug(`[${requestId}] ${method} ${url} completed in ${duration}ms with status ${status}`);
        },
        error: (error) => {
          // 请求失败
          const duration = Date.now() - startTime;
          const status = error.status || 500;
          
          // 记录错误日志
          this.loggerService.logRequest({
            timestamp: new Date().toISOString(),
            requestId,
            path: url,
            method,
            userId: user?.sub,
            ip,
            status,
            duration,
            serviceId: 'gateway',
            userAgent,
            requestBody: request.body,
            error: error.message,
          });
          
          this.logger.error(`[${requestId}] ${method} ${url} failed in ${duration}ms: ${error.message}`);
        },
      }),
    );
  }
}
```

日志服务实现：

```typescript
// 日志服务
// apps/gateway/src/logger/logger.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RedisService } from '@app/cache';
import { ApiLog } from './interfaces/api-log.interface';

@Injectable()
export class LoggerService {
  private readonly logger = new Logger(LoggerService.name);
  private readonly logQueue = 'gateway:logs';
  
  constructor(
    private readonly configService: ConfigService,
    private readonly redisService: RedisService,
  ) {}
  
  /**
   * 记录API请求日志
   * @param log 日志数据
   */
  async logRequest(log: ApiLog): Promise<void> {
    try {
      // 根据配置决定是否记录请求体和响应体
      const shouldLogBodies = this.configService.get<boolean>('LOG_REQUEST_BODIES', false);
      if (!shouldLogBodies) {
        delete log.requestBody;
        delete log.responseBody;
      }
      
      // 发布日志到Redis队列
      await this.redisService.rpush(this.logQueue, JSON.stringify(log));
      
      // 控制队列长度，避免内存溢出
      const maxQueueLength = this.configService.get<number>('MAX_LOG_QUEUE_LENGTH', 10000);
      const queueLength = await this.redisService.llen(this.logQueue);
      
      if (queueLength > maxQueueLength) {
        // 移除最早的日志
        await this.redisService.ltrim(this.logQueue, queueLength - maxQueueLength, -1);
      }
    } catch (error) {
      this.logger.error(`Error logging request: ${error.message}`);
    }
  }
  
  /**
   * 获取最近的日志
   * @param limit 日志数量
   */
  async getRecentLogs(limit: number = 100): Promise<ApiLog[]> {
    try {
      const logs = await this.redisService.lrange(this.logQueue, -limit, -1);
      return logs.map(log => JSON.parse(log));
    } catch (error) {
      this.logger.error(`Error getting recent logs: ${error.message}`);
      return [];
    }
  }
}
```

### 3.6 响应缓存模块实现

```typescript
// 缓存拦截器
// apps/gateway/src/cache/interceptors/cache.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, Logger } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request } from 'express';
import { CacheService } from '../cache.service';
import { CacheConfigService } from '../cache-config.service';

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  private readonly logger = new Logger(CacheInterceptor.name);
  
  constructor(
    private readonly cacheService: CacheService,
    private readonly configService: CacheConfigService,
  ) {}
  
  /**
   * 拦截请求进行缓存处理
   * @param context 执行上下文
   * @param next 下一个处理器
   */
  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    // 仅对GET请求进行缓存
    const request = context.switchToHttp().getRequest<Request>();
    if (request.method !== 'GET') {
      return next.handle();
    }
    
    const path = request.url;
    const cacheConfig = this.configService.getCacheConfig(path);
    
    // 如果没有缓存配置，直接处理请求
    if (!cacheConfig) {
      return next.handle();
    }
    
    // 构建缓存键
    const cacheKey = this.buildCacheKey(request, cacheConfig);
    
    try {
      // 尝试从缓存获取
      const cachedResponse = await this.cacheService.get(cacheKey);
      if (cachedResponse) {
        this.logger.debug(`Cache hit for ${path}`);
        return new Observable(observer => {
          observer.next(cachedResponse);
          observer.complete();
        });
      }
      
      // 缓存未命中，处理请求并缓存结果
      this.logger.debug(`Cache miss for ${path}`);
      return next.handle().pipe(
        tap(response => {
          this.cacheService.set(cacheKey, response, cacheConfig.ttl);
        }),
      );
    } catch (error) {
      this.logger.error(`Cache error for ${path}: ${error.message}`);
      // 缓存出错，继续处理请求但不缓存结果
      return next.handle();
    }
  }
  
  /**
   * 构建缓存键
   * @param request 请求对象
   * @param cacheConfig 缓存配置
   * @returns 缓存键
   */
  private buildCacheKey(request: Request, cacheConfig: any): string {
    const { path, query } = request;
    const user = request['user'];
    
    // 基础缓存键
    let key = `cache:${path}`;
    
    // 如果需要按用户区分缓存
    if (cacheConfig.varyByUser && user) {
      key += `:user:${user.sub}`;
    }
    
    // 如果需要按查询参数区分缓存
    if (cacheConfig.varyByParams && cacheConfig.varyByParams.length > 0) {
      const params = cacheConfig.varyByParams
        .filter(param => query[param] !== undefined)
        .map(param => `${param}=${query[param]}`)
        .join('&');
      
      if (params) {
        key += `:params:${params}`;
      }
    }
    
    return key;
  }
}
```

缓存服务实现：

```typescript
// 缓存服务
// apps/gateway/src/cache/cache.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RedisService } from '@app/cache';

@Injectable()
export class CacheService {
  private readonly logger = new Logger(CacheService.name);
  private readonly PREFIX = 'gateway:cache:';
  
  constructor(
    private readonly redisService: RedisService,
  ) {}
  
  /**
   * 从缓存获取数据
   * @param key 缓存键
   * @returns 缓存数据或null
   */
  async get(key: string): Promise<any> {
    try {
      const data = await this.redisService.get(`${this.PREFIX}${key}`);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      this.logger.error(`Error getting cache for ${key}: ${error.message}`);
      return null;
    }
  }
  
  /**
   * 将数据存入缓存
   * @param key 缓存键
   * @param value 缓存值
   * @param ttl 过期时间(秒)
   */
  async set(key: string, value: any, ttl: number): Promise<void> {
    try {
      await this.redisService.set(
        `${this.PREFIX}${key}`,
        JSON.stringify(value),
        'EX',
        ttl
      );
    } catch (error) {
      this.logger.error(`Error setting cache for ${key}: ${error.message}`);
    }
  }
  
  /**
   * 删除缓存
   * @param key 缓存键
   */
  async delete(key: string): Promise<void> {
    try {
      await this.redisService.del(`${this.PREFIX}${key}`);
    } catch (error) {
      this.logger.error(`Error deleting cache for ${key}: ${error.message}`);
    }
  }
  
  /**
   * 按模式删除缓存
   * @param pattern 模式
   */
  async deleteByPattern(pattern: string): Promise<void> {
    try {
      const keys = await this.redisService.keys(`${this.PREFIX}${pattern}`);
      if (keys.length > 0) {
        await this.redisService.del(keys);
        this.logger.debug(`Deleted ${keys.length} cache keys matching ${pattern}`);
      }
    } catch (error) {
      this.logger.error(`Error deleting cache by pattern ${pattern}: ${error.message}`);
    }
  }
}
```

### 3.7 异常过滤器实现

```typescript
// HTTP异常过滤器
// apps/gateway/src/filters/http-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException, Logger } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(HttpExceptionFilter.name);
  
  /**
   * 处理HTTP异常
   * @param exception 异常对象
   * @param host 参数宿主
   */
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();
    const exceptionResponse = exception.getResponse();
    
    const requestId = request['requestId'] || 'unknown';
    
    // 构建错误响应
    const errorResponse = {
      status,
      message: typeof exceptionResponse === 'object'
        ? (exceptionResponse as any).message || exception.message
        : exception.message,
      code: typeof exceptionResponse === 'object'
        ? (exceptionResponse as any).code || 'HTTP_ERROR'
        : 'HTTP_ERROR',
      path: request.url,
      timestamp: new Date().toISOString(),
      traceId: requestId,
    };
    
    this.logger.error(`[${requestId}] ${request.method} ${request.url} - ${status}: ${errorResponse.message}`);
    
    // 发送错误响应
    response.status(status).json(errorResponse);
  }
}
```

所有异常过滤器实现：

```typescript
// 所有异常过滤器
// apps/gateway/src/filters/all-exceptions.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpStatus, Logger } from '@nestjs/common';
import { Request, Response } from 'express';
import { HttpAdapterHost } from '@nestjs/core';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);
  
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}
  
  /**
   * 处理所有异常
   * @param exception 异常对象
   * @param host 参数宿主
   */
  catch(exception: unknown, host: ArgumentsHost) {
    const { httpAdapter } = this.httpAdapterHost;
    
    const ctx = host.switchToHttp();
    const request = ctx.getRequest<Request>();
    const response = ctx.getResponse<Response>();
    
    const requestId = request['requestId'] || 'unknown';
    
    // 确定HTTP状态码
    const httpStatus = this.getHttpStatus(exception);
    
    // 获取错误消息
    const message = this.getErrorMessage(exception);
    
    // 构建错误响应
    const responseBody = {
      status: httpStatus,
      message,
      code: 'INTERNAL_ERROR',
      path: request.url,
      timestamp: new Date().toISOString(),
      traceId: requestId,
    };
    
    // 记录错误日志
    if (httpStatus >= 500) {
      this.logger.error(
        `[${requestId}] ${request.method} ${request.url} - ${httpStatus}: ${message}`,
        exception instanceof Error ? exception.stack : undefined,
      );
    } else {
      this.logger.warn(`[${requestId}] ${request.method} ${request.url} - ${httpStatus}: ${message}`);
    }
    
    // 发送错误响应
    httpAdapter.reply(response, responseBody, httpStatus);
  }
  
  /**
   * 获取HTTP状态码
   * @param exception 异常对象
   * @returns HTTP状态码
   */
  private getHttpStatus(exception: unknown): number {
    // 尝试从异常中获取状态码
    if (exception instanceof Error) {
      if ('getStatus' in exception && typeof (exception as any).getStatus === 'function') {
        return (exception as any).getStatus();
      }
      
      if ('status' in exception && typeof (exception as any).status === 'number') {
        return (exception as any).status;
      }
    }
    
    // 默认使用500内部服务器错误
    return HttpStatus.INTERNAL_SERVER_ERROR;
  }
  
  /**
   * 获取错误消息
   * @param exception 异常对象
   * @returns 错误消息
   */
  private getErrorMessage(exception: unknown): string {
    if (exception instanceof Error) {
      return exception.message;
    }
    
    if (typeof exception === 'string') {
      return exception;
    }
    
    return 'Internal server error';
  }
}
```

## 四、部署设计

### 4.1 Docker部署方案

```dockerfile
# apps/gateway/Dockerfile
FROM node:18-alpine AS builder

# 创建工作目录
WORKDIR /app

# 复制package.json和lock文件
COPY package.json pnpm-lock.yaml ./

# 安装依赖
RUN npm install -g pnpm && pnpm install

# 复制源代码
COPY . .

# 构建网关服务
RUN pnpm run build gateway

# 运行阶段
FROM node:18-alpine AS runner

WORKDIR /app

# 复制构建产物和必要文件
COPY --from=builder /app/dist/apps/gateway ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

# 设置环境变量
ENV NODE_ENV=production

# 暴露端口
EXPOSE 3000

# 启动网关服务
CMD ["node", "dist/main.js"]
```

### 4.2 Kubernetes部署方案

```yaml
# kubernetes/gateway-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  namespace: react-nest-admin
  labels:
    app: api-gateway
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      containers:
      - name: api-gateway
        image: ${REGISTRY}/api-gateway:${VERSION}
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: REDIS_HOST
          value: "redis-service"
        - name: REDIS_PORT
          value: "6379"
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: api-gateway-secrets
              key: jwt-secret
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 15
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: api-gateway-service
  namespace: react-nest-admin
spec:
  selector:
    app: api-gateway
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-gateway-ingress
  namespace: react-nest-admin
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /$1
spec:
  ingressClassName: nginx
  rules:
  - host: api.react-nest-admin.com
    http:
      paths:
      - path: /(.*)
        pathType: Prefix
        backend:
          service:
            name: api-gateway-service
            port:
              number: 80
  tls:
  - hosts:
    - api.react-nest-admin.com
    secretName: api-tls-secret
```

## 五、网关功能对照表

下表汇总了不同微服务架构组件中可能放在网关层或服务层的功能：

| 功能点         | 网关层实现 | 服务层实现 | 建议位置 | 说明 |
|---------------|-----------|-----------|---------|------|
| 路由转发       | ✓         | ✗         | 网关层   | 网关作为统一入口，必须实现路由功能 |
| 认证鉴权       | ✓         | ✓/✗       | 网关层   | 集中处理令牌验证，服务层可选择性验证 |
| 限流熔断       | ✓         | ✓/✗       | 网关层+服务层 | 网关实现全局限流，服务层实现细粒度控制 |
| 请求日志       | ✓         | ✓/✗       | 网关层为主 | 网关统一记录所有请求，服务层记录详细操作 |
| 服务发现       | ✓         | ✓         | 两层结合 | 网关需要发现服务，服务需要注册自身 |
| 负载均衡       | ✓         | ✗         | 网关层   | 作为入口层分发请求给多个服务实例 |
| 响应缓存       | ✓         | ✓/✗       | 按需选择 | 通用缓存在网关层，业务缓存在服务层 |
| 协议转换       | ✓         | ✗         | 网关层   | 对外统一REST，内部可用不同协议通信 |
| 请求聚合       | ✓         | ✗         | 网关层   | 合并多个服务请求，减少客户端通信次数 |
| 灰度发布       | ✓         | ✓/✗       | 网关层为主 | 网关根据规则路由到不同版本服务 |
| SSL终结       | ✓         | ✗         | 网关层   | 网关层处理HTTPS，内部服务使用HTTP |
| 跨域处理       | ✓         | ✗         | 网关层   | 统一处理CORS相关问题 |
| 统一错误处理   | ✓         | ✓         | 两层结合 | 网关提供统一错误格式，服务提供详细错误 |
| 业务逻辑       | ✗         | ✓         | 服务层   | 业务逻辑应放在服务层实现 |
| 数据库访问     | ✗         | ✓         | 服务层   | 数据库操作仅在服务层进行 |
| 事件发布订阅   | ✓/✗        | ✓         | 服务层为主 | 服务间通信主要在服务层，网关可发布全局事件 |

## 六、实施建议

### 6.1 优先级排序

在微服务架构改造中，网关功能的实施建议按以下优先级进行：

1. **核心功能（必须先实现）**
   - 路由转发
   - 认证鉴权
   - 请求日志
   - 统一错误处理

2. **重要功能（可在第二阶段实现）**
   - 服务发现与注册
   - 限流熔断
   - 负载均衡
   - SSL终结

3. **优化功能（可在系统稳定后实现）**
   - 响应缓存
   - 请求聚合
   - 灰度发布
   - 协议转换

### 6.2 注意事项

1. **性能考虑**
   - 网关作为所有请求的入口，是潜在的性能瓶颈
   - 避免在网关中进行复杂计算
   - 考虑网关的水平扩展能力

2. **安全考虑**
   - 严格控制网关的访问权限
   - 实现完善的认证和授权机制
   - 定期审计日志并监控异常请求

3. **可用性考虑**
   - 网关故障将影响整个系统
   - 实现网关的高可用部署
   - 考虑故障转移和灾难恢复策略

4. **可维护性考虑**
   - 保持网关配置的简单和清晰
   - 实现动态配置更新能力
   - 完善的监控和告警机制

## 七、总结

API网关是微服务架构的关键组件，承担着请求路由、认证鉴权、监控日志等核心职责。在我们的单仓微服务架构中，建议使用自研NestJS网关结合NGINX，以充分利用现有技术栈，同时确保性能和稳定性。

网关的功能应当专注于请求处理、转发和跨切面关注点，而将业务逻辑保留在各微服务中。通过合理的功能分配和优先级规划，可以确保微服务架构的顺利落地和系统的长期健康运行。

按照本文档提供的实现方案和代码示例，可以构建一个功能完善、性能优良的API网关，为后续的微服务改造工作奠定基础。